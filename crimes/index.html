<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="referrer" content="no-referrer">

        <!-- Enable responsiveness on mobile devices-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <title>Inverse crimes | Ages and orbs</title>
<meta property="og:title" content="Inverse crimes | Ages and orbs" />
<meta name="twitter:title" content="Inverse crimes | Ages and orbs" />
<meta name="twitter:card" content="summary" />
<meta property="og:description" content="It takes some care to test your model on synthetic data that&#x27;s really independent from your model." />
<meta name="og:image" content="https:&#x2F;&#x2F;muireall.space&#x2F;crimes&#x2F;card.png" />
<meta name="twitter:image" content="https:&#x2F;&#x2F;muireall.space&#x2F;crimes&#x2F;card.png" />

        

        <meta property="og:site_name" content="Ages and orbs" />
        <meta property="og:url" content="https:&#x2F;&#x2F;muireall.space" />

        

        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
<link rel="stylesheet" href="https://muireall.space/base.css" />
<link rel="stylesheet" href="https://muireall.space/notes.css" />
<link rel="stylesheet" href="https://muireall.space/math.css" />
<link rel="stylesheet" href="https://muireall.space/tables.css" />
<link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@200;300;400;600&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:wght@300;400&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<link href="https://muireall.space/fontawesome/fontawesome.css" rel="stylesheet">
<link href="https://muireall.space/fontawesome/brands.css" rel="stylesheet">
<link href="https://muireall.space/fontawesome/solid.css" rel="stylesheet">

        <link rel='icon' type='image/x-icon' href="https://muireall.space/favicon.ico" />

        <link rel="alternate" type="application/atom+xml" title="Ages and orbs" href="https://muireall.space/atom.xml">

        

    </head>
    <body>
        <a href="#main" class="skip-link p-screen-reader-text">Skip to content</a>
        <header class="l-header">
            <h1 class="c-title p-title"><a href="https:&#x2F;&#x2F;muireall.space" class="p-title__link">Ages and orbs</a></h1>
            </header>

        <main id="main" class="l-main">
            
<article class="p-article h-entry">
    <header>
        <h1 class="p-name">Inverse crimes
</h1>
        <div>
            <div class="c-time">
                <time class="dt-published" datetime="2022-01-04">
                    2022-01-04
                </time>
                 — (12 min read)
            </div>
        </div>
    </header>
    
    <section id="js-article" class="p-article__body e-content">
        <p>Mathematician Rainer Kress <a href="https://scicomp.stackexchange.com/questions/28225/first-appearance-of-the-phrase-inverse-crime">coined</a> a cute name for an insidious kind of triviality: the inverse crime.<sup class="sidenote-widget"><a href="#ref1" id="backref1">1</a></sup><div class="note">
<p>
  <a id="ref1"></a>
  <sup class="sidenote-widget">
  1
  </sup> D. Colton and R. Kress, <em>Inverse Acoustic and Electromagnetic Scattering Theory</em>, 4th ed. Springer Nature, 2019, p. 179.
  <a href="#backref1" class="sidenote-widget">
  ⏎
  </a>
</p>
</div></p>
<span id="continue-reading"></span>
<p>His usage comes from the study of inverse scattering problems: if you shine light on an object, the light scatters off of it. If you measure the scattered light—the brightness when viewed from different angles—you can reconstruct the object (invert the scattering). The mathematical object that does this is your inverse solver.</p>
<p>The opportunity for crime comes when you test how well your inverse solver works. To do that, you use a forward solver to calculate the scattered light you expect to see for some object (“synthetic data”). Then you run your inverse solver on that synthetic data and see how well the reconstructed object matches the object you started with.</p>
<p>The crime itself is a question of the relationship between your forward and inverse solvers. Kress is concerned about synthetic data that was (or could have been) generated by the forward operator underlying or implied by the inverse solver. In such a case, it’s no surprise when inversion appears successful. From another perspective, if the two solvers are equivalent in some sense—they implicitly or explicitly use the same ideas, they assume the same things, they approximate to the same order, they share code—one could accuse you of some degree of inverse crime.</p>
<p>In the worst case, if the relationship between the forward and inverse solvers is trivial inversion, then you’re not testing whether your inverse solver is correct. You’re testing whether it’s a correct implementation of undoing the forward solver’s operations step by step.</p>
<p>Inverse crimes vary just as do degrees and senses in which the forward and inverse solvers are connected. What they have in common, and what distinguishes them from non-criminal cases, is that your validation method can’t give you all the information you want about correctness—and it invites you to fool yourself about it.</p>
<h2 id="examples">Examples<a class="zola-anchor" href="#examples" aria-label="Anchor link for: examples"><i class="fas fa-link"></i></a> 
</h2>
<p>Inverse crimes concern synthetic data and validation in general, not just in scattering problems.</p>
<p>One trivial inversion occurs when, to unit test a method <code>f</code>, you run <code>f(2)</code> to get an answer (<code>2.571</code>) and then add <code>@test f(2) == 2.571</code> to your test suite. That’ll catch a change in <code>f</code>’s behavior, but is it the right behavior?</p>
<p>Or if your test suite passes <code>@test f(g(x)) == x</code> for various values of <code>x</code>, then you’ve validated only that <code>f</code> inverts <code>g</code>. That’s meaningful, but you still can’t say that either function does what you want.</p>
<p>These are easy to spot and relatively easily fixed, but crimes are often subtle! You may not think of your tests as inverting anything, and a moral equivalence can be buried deep.</p>
<p>In machine learning, training on the test set can be viewed as an inverse crime. Even iterating on a model to get better performance on the test set falls under the shadow, along with a number of other surreptitious or accidental ways of accomplishing the same thing.</p>
<p>Problems of doublecounting evidence or confirmation bias can be cast in terms of inversion.</p>
<p>(Nontriviality can also be subtle. If you want to invert <code>f(x) = x^2</code>, you have two possible solutions. If your inverse solver picks out one, that’s informative in a way that may require interpretation. <a href="https://arxiv.org/abs/math-ph/0401050">Wirgin (2004)</a> elaborates on the subject.)<sup class="sidenote-widget"><a href="#ref2" id="backref2">2</a></sup><div class="note">
<p>
  <a id="ref2"></a>
  <sup class="sidenote-widget">
  2
  </sup> A. Wirgin, “The inverse crime,” <a href="https://arxiv.org/abs/math-ph/0401050">arXiv:math-ph/0401050</a>, Jan. 2004.
  <a href="#backref2" class="sidenote-widget">
  ⏎
  </a>
</p>
</div></p>
<h2 id="in-depth-curve-fitting-for-filter-characterization">In depth: Curve fitting for filter characterization<a class="zola-anchor" href="#in-depth-curve-fitting-for-filter-characterization" aria-label="Anchor link for: in-depth-curve-fitting-for-filter-characterization"><i class="fas fa-link"></i></a> 
</h2>
<p>Here’s a trickier and more realistic case. I want to fit transmission spectra of some filters—say, transmitted power as a function of frequency for optical ring resonators in a notch (or “all-pass”) configuration. There’s no real lesson at the end of this—it’s more of an exercise in thinking about model validation.</p>
<h4 id="first-attempt-trivial-inversion">First attempt: Trivial inversion<a class="zola-anchor" href="#first-attempt-trivial-inversion" aria-label="Anchor link for: first-attempt-trivial-inversion"><i class="fas fa-link"></i></a> 
</h4>
<p>I remember that the energy of a resonator decays exponentially in time, so it should have a Lorentzian lineshape in the frequency domain. With a little reasoning about special cases I can guess a specific functional form, and write a method to fit the parameters to some data.</p>
<pre data-lang="julia" style="background-color:#ffffff;color:#323232;" class="language-julia "><code class="language-julia" data-lang="julia"><span style="font-weight:bold;color:#a71d5d;">using</span><span> Optim
</span><span style="font-weight:bold;color:#a71d5d;">using</span><span> Zygote
</span><span style="font-weight:bold;color:#a71d5d;">using</span><span> GLMakie
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">function </span><span style="font-weight:bold;color:#795da3;">power_transmission_spectrum</span><span>(ω, # frequency
</span><span>        ω_0, # resonant frequency
</span><span>        κ_i, # intrinsic loss
</span><span>        κ_e) </span><span style="font-style:italic;color:#969896;"># extrinsic loss
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">-</span><span> κ_i </span><span style="font-weight:bold;color:#a71d5d;">*</span><span> κ_e </span><span style="font-weight:bold;color:#a71d5d;">/ </span><span>((ω </span><span style="font-weight:bold;color:#a71d5d;">-</span><span> ω_</span><span style="color:#0086b3;">0</span><span>)</span><span style="font-weight:bold;color:#a71d5d;">^</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span>((κ_i </span><span style="font-weight:bold;color:#a71d5d;">+</span><span> κ_e)</span><span style="font-weight:bold;color:#a71d5d;">/</span><span style="color:#0086b3;">2</span><span>)</span><span style="font-weight:bold;color:#a71d5d;">^</span><span style="color:#0086b3;">2</span><span>)
</span><span style="font-weight:bold;color:#a71d5d;">end
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">function </span><span style="font-weight:bold;color:#795da3;">fit_transmission</span><span>(ωs, data, p_0)
</span><span>    loss(p) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> sum(abs</span><span style="color:#0086b3;">2.</span><span>(
</span><span>        power_transmission_spectrum.(ωs, p...) </span><span style="font-weight:bold;color:#a71d5d;">.-</span><span> data))
</span><span>    g</span><span style="font-weight:bold;color:#a71d5d;">!</span><span>(G, p) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>(G </span><span style="font-weight:bold;color:#a71d5d;">.=</span><span> loss</span><span style="color:#183691;">&#39;</span><span style="background-color:#f5f5f5;font-weight:bold;color:#b52a1d;">(p)) #</span><span style="color:#183691;">&#39;</span><span style="font-style:italic;color:#969896;"># silly syntax highlighter
</span><span>    h</span><span style="font-weight:bold;color:#a71d5d;">!</span><span>(H, p) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>(H </span><span style="font-weight:bold;color:#a71d5d;">.=</span><span> hessian(loss, p))
</span><span>    result </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> optimize(loss, g</span><span style="font-weight:bold;color:#a71d5d;">!</span><span>, h</span><span style="font-weight:bold;color:#a71d5d;">!</span><span>, p_</span><span style="color:#0086b3;">0</span><span>)
</span><span style="font-weight:bold;color:#a71d5d;">end
</span></code></pre>
<p>This should approximate my devices pretty well, but I’d like to see some evidence. I could generate synthetic data the easy way, by adding noise to the transmission function I already wrote:</p>
<pre data-lang="julia" style="background-color:#ffffff;color:#323232;" class="language-julia "><code class="language-julia" data-lang="julia"><span style="font-weight:bold;color:#a71d5d;">function </span><span style="font-weight:bold;color:#795da3;">synthesize_data</span><span>(ωs, p, noise_amplitude=0.1)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> power_transmission_spectrum.(ωs, p...) </span><span style="font-weight:bold;color:#a71d5d;">.+ 
</span><span>        noise_amplitude</span><span style="font-weight:bold;color:#a71d5d;">*</span><span>randn(length(ωs))
</span><span style="font-weight:bold;color:#a71d5d;">end
</span><span>
</span><span>ωs </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> range(</span><span style="font-weight:bold;color:#a71d5d;">-</span><span style="color:#0086b3;">0.5</span><span>, </span><span style="color:#0086b3;">0.5</span><span>, length</span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#0086b3;">1000</span><span>)
</span><span>p_true </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>[</span><span style="color:#0086b3;">0.1</span><span>, </span><span style="color:#0086b3;">0.05</span><span>, </span><span style="color:#0086b3;">0.02</span><span>]
</span><span>data </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> synthesize_data(ωs, p_true)
</span><span>result </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> fit_transmission(ωs, data,
</span><span>    [ωs[argmin(data)], </span><span style="color:#0086b3;">0.01</span><span>, </span><span style="color:#0086b3;">0.01</span><span>])
</span></code></pre>
<pre data-lang="PowerShell" style="background-color:#ffffff;color:#323232;" class="language-PowerShell "><code class="language-PowerShell" data-lang="PowerShell"><span>julia</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span> result.minimizer
</span><span style="color:#0086b3;">3</span><span style="font-weight:bold;color:#a71d5d;">-</span><span>element Vector{Float64}:
</span><span> </span><span style="color:#0086b3;">0.10094963595329196
</span><span> </span><span style="color:#0086b3;">0.01968074906926952
</span><span> </span><span style="color:#0086b3;">0.051693643609924414
</span><span>julia</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span> fig</span><span style="font-weight:bold;color:#a71d5d;">,</span><span> ax </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> scatter(ωs</span><span style="font-weight:bold;color:#a71d5d;">, data,</span><span> color</span><span style="font-weight:bold;color:#a71d5d;">=</span><span>:darkblue);
</span><span>julia</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span> ax.xlabel </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;δω&quot;</span><span>;
</span><span>julia</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span> ax.ylabel </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Normalized transmitted power&quot;</span><span>;
</span><span>julia</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span> lines</span><span style="font-weight:bold;color:#a71d5d;">!</span><span>(ωs</span><span style="font-weight:bold;color:#a71d5d;">,</span><span> power_transmission_spectrum.(ωs</span><span style="font-weight:bold;color:#a71d5d;">,
</span><span>    result.minimizer...)</span><span style="font-weight:bold;color:#a71d5d;">,</span><span> color</span><span style="font-weight:bold;color:#a71d5d;">=</span><span>:red</span><span style="font-weight:bold;color:#a71d5d;">,</span><span> linewidth</span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#0086b3;">5</span><span>);
</span><span>julia</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span> current_figure()
</span></code></pre>
<p>
<img src="https:&#x2F;&#x2F;muireall.space&#x2F;processed_images&#x2F;709fb2794fd4e28800.png" alt=""/>
The test helpfully reminds me that my transmission formula is symmetric in the intrinsic and extrinsic loss.<sup class="sidenote-widget"><a href="#note1" id="backnote1">&#97;
  </a>
</sup>
<span class="note" >
  <a id="note1"></a>
  <sup class="sidenote-widget">
    &#97;
  </sup> In fact, if I had used a gradient-only method, the fit could have gotten stuck at a saddle point with the two losses equal.
  <a href="#backnote1" class="sidenote-widget">
  ⏎
  </a>
</span> That’s important for interpreting results, so at some point I’ll have to think of another way of distinguishing the two.</p>
<p>Still, this isn’t the test I really wanted. It tests whether <code>optimize</code> inverts adding noise to the transmission spectrum. Or, no, whether <code>optimize</code> inverts adding noise to my specific single implementation <code>power_transmission_spectrum</code>. If my calculation of the transmission spectrum is a bad approximation, or if I made a typo and it’s entirely wrong, I’ll never know.</p>
<h4 id="second-attempt-disguised-inversion">Second attempt: Disguised inversion<a class="zola-anchor" href="#second-attempt-disguised-inversion" aria-label="Anchor link for: second-attempt-disguised-inversion"><i class="fas fa-link"></i></a> 
</h4>
<p>Well, maybe I should come up with a different way to generate test data. I remember that resonators can be modeled like RLC circuits, so I can find the resistance, inductance, and capacitance corresponding to my Lorentzian parameters, then put that circuit into a SPICE simulator or something entirely disconnected from my code.</p>
<p>That strategy’s well-intentioned, but it’s still a crime, as it turns out. Sure, it’s less egregious, but the RLC circuit isn’t another independent way of modeling an ideal resonator—it’s exactly equivalent to the Lorentzian in the sense that matters. The parameters <code>R</code>, <code>L</code>, and <code>C</code> (scaled to an input/output impedance <code>Z_0</code>) contain the same information as <code>ω_0</code>, <code>κ_e</code>, and <code>κ_i</code>. The approximation to the underlying physical process is identical. It’s possible I’ll catch implementation bugs, but that’s not enough. I want to test how good that approximation is.</p>
<h4 id="third-attempt-physical-derivation">Third attempt: Physical derivation<a class="zola-anchor" href="#third-attempt-physical-derivation" aria-label="Anchor link for: third-attempt-physical-derivation"><i class="fas fa-link"></i></a> 
</h4>
<p>To do this, we had best understand where the approximation comes from.<sup class="sidenote-widget"><a href="#note2" id="backnote2">&#98;
  </a>
</sup>
<span class="note" >
  <a id="note2"></a>
  <sup class="sidenote-widget">
    &#98;
  </sup> For some problems, you can get away without understanding if you get your hands on calibration standards or datasets.
  <a href="#backnote2" class="sidenote-widget">
  ⏎
  </a>
</span> Light in an input waveguide passes by the ring with some light coupling into the ring and circulating, accumulating phase <script type="math/tex">\varphi</script>
 with each round trip. The circulating amplitude <script type="math/tex">α</script>
 decays over time <script type="math/tex">(a),</script>
 radiating away or bouncing off of imperfections in the ring. It also couples back into the waveguide with each round trip <script type="math/tex">(k),</script>
 interfering with the input light that passed through <script type="math/tex">(r).</script>
 We can solve for the amplitude in the ring in the steady state, and it looks like this:</p>
<p><script type="math/tex;mode=display">\begin{align}
\alpha &= \alpha_{\text{in}} k + \alpha_{\text{in}} k (ra\, e^{-i φ}) + \alpha_{\text{in}} k (ra\, e^{-i φ})^2 + ... \notag\\
    &= \frac{\alpha_{\text{in}} k }{1 - ra\, e^{-i φ}}\notag\\
\alpha_\text{out} &= \alpha_\text{in} r - \alpha k \notag\\   
\frac{\alpha_\text{out}}{\alpha_\text{in}} &= r - \frac{k^2}{1 - ra\, e^{-i φ}} \notag\\
    &= e^{-iφ}\frac{r - r^2a - (1-r^2)e^{iφ}}{1-ra\, e^{-iφ}}\notag\\
    &= e^{-iφ}\frac{(a-1)(1-r^2) -a + r\, e^{iφ}}{1-ra\, e^{-iφ}} \\
\left\lvert\frac{\alpha_\text{out}}{\alpha_\text{in}}\right\rvert^2 &\approx \frac{r^2 + a^2 - 2ra\cos φ}{1 + (ra)^2 - 2ra\cos φ}
\end{align}</script>

We’ve already made a couple assumptions: that <script type="math/tex">k^2 = 1 - r^2</script>
 (there’s no loss in the coupler), and that <script type="math/tex">(1-a)(1-r^2) \ll a .</script>
 We might use either Eqn. 1 or 2 to generate synthetic data.</p>
<h6 id="technical-note-how-do-you-get-to-the-lorentzian">Technical note: How do you get to the Lorentzian?<a class="zola-anchor" href="#technical-note-how-do-you-get-to-the-lorentzian" aria-label="Anchor link for: technical-note-how-do-you-get-to-the-lorentzian"><i class="fas fa-link"></i></a> 
</h6>
<p>Resonance occurs when the denominator is minimized, at <script type="math/tex">\cos φ = 1</script>
 or <script type="math/tex">φ~=~2π n</script>
 for integer <script type="math/tex">n</script>
. We can expand in small <script type="math/tex">\delta φ</script>
 around that value:
<script type="math/tex;mode=display">\begin{align*}
\left\lvert\frac{\alpha_\text{out}}{\alpha_\text{in}}\right\rvert^2 &\approx \frac{(r - a)^2 + ra\,\delta φ^2}{(1 - ra)^2 + ra\,\delta φ^2} \\
&= 1 - \frac{(1 - r^2)(1 - a^2)}{(1 - ra)^2 + ra\,\delta φ^2}.
\end{align*}</script>

If we define <script type="math/tex">k_1 = \frac{(1+r)(1-a)}{\sqrt{ra}}, k_2 = \frac{(1-r)(1+a)}{\sqrt{ra}}</script>
, then</p>
<script type="math/tex;mode=display">\begin{align*}
\left\lvert\frac{\alpha_\text{out}}{\alpha_\text{in}}\right\rvert^2 &\approx 1 - \frac{k_1 k_2}{\left(\frac{k_1+k_2}{2}\right)^2 + \delta φ^2}.
\end{align*}</script>
<p>This is the functional form we wanted, but <script type="math/tex">k_1, k_2</script>
 don’t correspond to the intrinsic and extrinsic <script type="math/tex">\kappa_i, \kappa_e .</script>
 In fact, if we want <script type="math/tex">\kappa_i \propto 1-a^2</script>
 and <script type="math/tex">\kappa_e \propto 1-r^2,</script>
then</p>
<p><script type="math/tex;mode=display">\begin{align*}
\left\lvert\frac{a_\text{out}}{a_\text{in}}\right\rvert^2 &\approx 1 - \frac{\kappa_i \kappa_e}{\big(\frac{\sqrt{ra}}{(r+a)/2}\frac{\kappa_i+\kappa_e}{2}\big)^2 + \delta \omega^2}.
\end{align*}</script>

So above I accidentally included an implicit approximation that gets worse the more different <script type="math/tex">a</script>
 and <script type="math/tex">r</script>
 are (the more different their arithmetic and geometric mean, or the further the device from critical coupling).<sup class="sidenote-widget"><a href="#note3" id="backnote3">&#99;
  </a>
</sup>
<span class="note" >
  <a id="note3"></a>
  <sup class="sidenote-widget">
    &#99;
  </sup> This is characteristic of Fabry Pérot resonators, where the “natural” Lorentzian lineshape due to exponential decay gets modified because the extrinsic coupling is presented to a circulating wave only periodically, not continuously. The exact expression should be expressible as a sum of Lorentzians that’s been named after George Biddell Airy, although it’s not the well-known Airy function. Unfortunately I can’t point to a source that goes to the trouble for the ring resonator case, but it’s somewhere between a Lorentzian and the discrete Fourier transform of a uniformly sampled exponential decay, I suppose.
  <a href="#backnote3" class="sidenote-widget">
  ⏎
  </a>
</span> I certainly wasn’t testing that before. How much does that matter, and how would I correct for it?</p>
<h6 id="why-approximate-at-all">Why approximate at all?<a class="zola-anchor" href="#why-approximate-at-all" aria-label="Anchor link for: why-approximate-at-all"><i class="fas fa-link"></i></a> 
</h6>
<p>Why don’t I just use the more accurate Eqn. 2 for my model? Sometimes that’s the best option. (One can even test it using synthetic data from an approximate model.) In this case, it’s kind of annoying, because <script type="math/tex">\varphi</script>
 is a strange parameter. The ring resonator supports many resonances periodic in frequency.<sup class="sidenote-widget"><a href="#note4" id="backnote4">&#100;
  </a>
</sup>
<span class="note" >
  <a id="note4"></a>
  <sup class="sidenote-widget">
    &#100;
  </sup> This period is known as the free spectral range (FSR). Sometimes you care more about the ratio of FSR to linewidth than about the linewidth (or quality factor) itself, in which case you may still want to determine FSR independently rather than use the realistic model.
  <a href="#backnote4" class="sidenote-widget">
  ⏎
  </a>
</span> Using <script type="math/tex">\varphi</script>
 in my parameterization forces me to pick one out, but I don’t really care which one it is. In other words, for my purposes, <script type="math/tex">\varphi</script>
 is effectively two parameters, <script type="math/tex">\delta\varphi</script>
 and <script type="math/tex">n,</script>
 the integer multiple used to satisfy the resonance condition. If I want, and if I’ve thought carefully about what it means, can’t I choose <script type="math/tex">n</script>
 arbitrarily? Then I have another 3-parameter model that shouldn’t give me any more trouble than the Lorentzian. But I really do care about <script type="math/tex">\kappa_i</script>
 more than the round-trip amplitude decay. The connection between <script type="math/tex">a, r,</script>
 and <script type="math/tex">\kappa_1, \kappa_2</script>
 depends on physical attributes of the filter (length and effective index) that I don’t necessarily know but would effectively be assuming by choosing <script type="math/tex">n.</script>
 It’s probably better to abstract all that away.</p>
<h6 id="other-details">Other details<a class="zola-anchor" href="#other-details" aria-label="Anchor link for: other-details"><i class="fas fa-link"></i></a> 
</h6>
<p>Once I encounter real data, I might find there are other details I have to account for to extract the information I want. Uneven background transmission, optical nonlinearities, photodetector dark counts, various sources of noise. Some details might be calibrated or otherwise preprocessed away, others might need to be part of my model. I’m probably not going to be able to keep my model innocent of feedback from its output; instead, I’ll have to adjust it based on how I judge its fit to the data. That doesn’t compromise the experiment, but it is one way confirmation bias creeps in. Keeping synthetic test data “physical” and out of the range of the model is one line of defense.</p>

    </section>
    <address class="p-author h-card" href=" https:&#x2F;&#x2F;muireall.space ">Muireall </address>
    <footer>
        <nav class="c-pagination p-pagination">
            <div class="c-pagination__ctrl">
                <div class="c-pagination__newer">
                    
                </div>
                <div class="c-pagination__older">
                    
                </div>
            </div>
        </nav>
    </footer>
</article>
        </main>

     
      <footer class="l-footer">
          <p class="p-copyright">
    
</p>
    <p style="text-align:center"><a href="https://twitter.com/MuireallPrase" rel="me">Twitter</a>
    ☙  <a href="mailto:muireall.prase@protonmail.com" rel="me">Email</a>  ❧ <a href="https://github.com/muireall" rel="me">GitHub</a></p>
    <p style="text-align:center"> <a class="h-card u-url" rel="me" href=https://muireall.space">Muireall Prase</a> </p>
      </footer>

       
      <link rel="stylesheet" href="https://muireall.space/css/katex.min.css">
      <script defer src="https://muireall.space/js/katex.min.js"></script>
      <script defer src="https://muireall.space/js/mathtex-script-type.min.js"></script>
    </body>
</html>
            
